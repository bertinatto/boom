# Copyright (C) 2017 Red Hat, Inc., Bryn M. Reeves <bmr@redhat.com>
#
# command.py - Boom BLS bootloader command interface
#
# This file is part of the boom project.
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions
# of the GNU General Public License v.2.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
import boom
from boom.osprofile import *
from boom.report import *
from boom.bootloader import *

import sys
from os.path import basename
from argparse import ArgumentParser


#
# Reporting object types
#

class BoomReportObj(object):
    """BoomReportObj()
        The universal object type used for all reports generated by
        the Boom CLI. Individual fields map to one of the contained
        objects via the ``BoomReportObjType`` object's ``data_fn``
        method. It is an error to attempt to report an object that
        is undefined: the BoomReportObj used for a report must
        contain values for each object type that the specified list
        of fields will attempt to access. FIXME: OR IS IT?!?!?!

        This allows a single report to include fields from both a
        ``BootEntry`` object and an attached ``OsProfile``.
    """
    be = None
    osp = None

    def __init__(self, boot_entry=None, os_profile=None):
        """__init__(self, boot_entry, os_profile) -> BoomReportObj

            Construct a new BoomReportObj object containing the
            specified BootEntry and or OsProfile objects.

            :returns: a new BoomReportObj.
            :returntype: ``BoomReportObj``
        """
        self.be = boot_entry
        self.osp = os_profile


BR_ENTRY = 1
BR_PROFILE = 2

_report_obj_types = [
    BoomReportObjType(
        BR_ENTRY, "Boot loader entries", "entry_", lambda o: o.be),
    BoomReportObjType(
        BR_PROFILE, "OS profiles", "profile_", lambda o: o.osp)
]

#
# Reporting field definitions
#

#: fields derived from OsProfile data.
_profile_fields = [
    BoomFieldType(
        BR_PROFILE, "osid", "OsID", "OS identifier", 7,
        REP_SHA, lambda f, d: f.report_sha(d.os_id)),
    BoomFieldType(
        BR_PROFILE, "osname", "Name", "OS name", 24,
        REP_STR, lambda f, d: f.report_str(d.name)),
    BoomFieldType(
        BR_PROFILE, "osshortname", "OsShortName", "OS short name", 12,
        REP_STR, lambda f, d: f.report_str(d.short_name)),
    BoomFieldType(
        BR_PROFILE, "osversion", "OsVersion", "OS version", 10,
        REP_STR, lambda f, d: f.report_str(d.version)),
    BoomFieldType(
        BR_PROFILE, "osversion_id", "VersionID", "Version identifier", 10,
        REP_STR, lambda f, d: f.report_str(d.version_id)),
    BoomFieldType(
        BR_PROFILE, "unamepattern", "UnamePattern", "UTS name pattern", 12,
        REP_STR, lambda f, d: f.report_str(d.uname_pattern)),
    BoomFieldType(
        BR_PROFILE, "kernelpattern", "KernPattern", "Kernel image pattern", 13,
        REP_STR, lambda f, d: f.report_str(d.kernel_pattern)),
    BoomFieldType(
        BR_PROFILE, "initrdpattern", "InitrdPattern", "Initrd pattern", 13,
        REP_STR, lambda f, d: f.report_str(d.initramfs_pattern)),
    BoomFieldType(
        BR_PROFILE, "lvm2opts", "LVM2Opts", "LVM2 options", 12,
        REP_STR, lambda f, d: f.report_str(d.root_opts_lvm2)),
    BoomFieldType(
        BR_PROFILE, "btrfsopts", "BTRFSOpts", "BTRFS options", 13,
        REP_STR, lambda f, d: f.report_str(d.root_opts_btrfs)),
    BoomFieldType(
        BR_PROFILE, "options", "Options", "Kernel options", 24,
        REP_STR, lambda f, d: f.report_str(d.options))
]

_default_profile_fields = "osid,osname,osversion"
_verbose_profile_fields = _default_profile_fields + ",unamepattern,options"

#: fields derived from BootEntry data.
_entry_fields = [
    BoomFieldType(
        BR_ENTRY, "bootid", "BootID", "Boot identifier", 7,
        REP_SHA, lambda f, d: f.report_sha(d.boot_id)),
    BoomFieldType(
        BR_ENTRY, "title", "Title", "Entry title", 24,
        REP_STR, lambda f, d: f.report_str(d.title)),
    BoomFieldType(
        BR_ENTRY, "version", "Version", "Kernel version", 24,
        REP_STR, lambda f, d: f.report_str(d.version)),
    BoomFieldType(
        BR_ENTRY, "options", "Options", "Kernel options", 24,
        REP_STR, lambda f, d: f.report_str(d.options)),
    BoomFieldType(
        BR_ENTRY, "kernel", "Kernel", "Kernel image", 32,
        REP_STR, lambda f, d: f.report_str(d.linux)),
    BoomFieldType(
        BR_ENTRY, "initramfs", "Initramfs", "Initramfs image", 40,
        REP_STR, lambda f, d: f.report_str(d.initrd)),
    BoomFieldType(
        BR_ENTRY, "machineid", "Machine ID", "Machine identifier", 12,
        REP_SHA, lambda f, d: f.report_sha(d.machine_id))
]

_default_entry_fields = "bootid,version,osid,osname,osversion"
_verbose_entry_fields = "bootid,version,kernel,initramfs,options,machineid"


#
# Command driven API: BootEntry and OsProfile management and reporting.
#

#
# BootEntry manipulation
#

def create_entry(title, version, machine_id, root_device, lvm_root_lv=None,
                 btrfs_subvol_path=None, btrfs_subvol_id=None, osprofile=None):
    """create_entry(title, version, machine_id, root_device, lvm_root_lv,
       btrfs_subvol_path, btrfs_subvol_id, osprofile) -> ``BootEntry``

        Create the specified boot entry in the configured loader directory.
        An error is raised if a matching entry already exists.

        :param title: the title of the new entry.
        :param version: the version string for the new entry.
        :param root_device: the root device path for the new entry.
        :param lvm_root_lv: an optional LVM2 root logical volume.
        :param btrfs_subvol_path: an optional BTRFS subvolume path.
        :param btrfs_subvol_id: an optional BTRFS subvolume id.
        :param osprofile: The ``OsProfile`` for this entry.
        :returns: a ``BootEntry`` object corresponding to the new entry.
        :returntype: ``BootEntry``
        :raises: ``ValueError`` if either required values are missing or
                 a duplicate entry exists, or``OsError`` if an error
                 occurs while writing the entry file.
    """
    if not title:
        raise ValueError("Entry title cannot be empty.")

    if not version:
        raise ValueError("Entry version cannot be empty.")

    if not machine_id:
        raise ValueError("Entry machine_id cannot be empty.")

    if not root_device:
        raise ValueError("Entry requires a root_device.")

    if not osprofile:
        raise ValueError("Cannot create entry without OsProfile.")

    btrfs = any([btrfs_subvol_path, btrfs_subvol_id])

    bp = BootParams(version, root_device, lvm_root_lv=lvm_root_lv,
                    btrfs_subvol_path=btrfs_subvol_path,
                    btrfs_subvol_id=btrfs_subvol_id)

    be = BootEntry(title=title, machine_id=machine_id,
                   osprofile=osprofile, boot_params=bp)
    if find_entries(boot_id=be.boot_id):
        raise ValueError("Entry already exists (boot_id=%s)." % be.boot_id)

    be.write_entry()

    return be


def delete_entries(boot_id=None, title=None, version=None,
                   machine_id=None, root_device=None, lvm_root_lv=None,
                   btrfs_subvol_path=None, btrfs_subvol_id=None):
    """delete_entries(boot_id, title, version,
                      machine_id, root_device, lvm_root_lv,
                      btrfs_subvol_path, btrfs_subvol_id) -> int

        Delete the specified boot entry or entries from the configured
        loader directory. If ``boot_id`` is used, or of the criteria
        specified match exactly one entry, a single entry is removed.
        If ``boot_id`` is not used, and more than one matching entry
        is present, all matching entries will be removed.

        On success the number of entries removed is returned.

        :param boot_id: ``boot_id`` to match.
        :param title: title string to match.
        :param version: version to match.
        :param root_device: root device path to match.
        :param lvm_root_lv: LVM2 root logical volume to match.
        :param btrfs_subvol_path: BTRFS subvolume path to match.
        :param btrfs_subvol_id: BTRFS subvolume id to match.
        :returns: the number of entries removed.
        :returntype: ``int``
    """
    bes = find_entries(boot_id=boot_id, title=title, version=version,
                       machine_id=machine_id, root_device=root_device,
                       lvm_root_lv=lvm_root_lv,
                       btrfs_subvol_path=btrfs_subvol_path,
                       btrfs_subvol_id=btrfs_subvol_id)

    if not bes:
        raise IndexError("No matching entry found.")

    deleted = 0
    for be in bes:
        be.delete_entry()
        deleted += 1

    return deleted


def list_entries(boot_id=None, title=None, version=None,
                 machine_id=None, root_device=None, lvm_root_lv=None,
                 btrfs_subvol_path=None, btrfs_subvol_id=None):
    """list_entries(boot_id, title, version,
                    machine_id, root_device, lvm_root_lv,
                    btrfs_subvol_path, btrfs_subvol_id) -> list

        Return a list of ``boom.bootloader.BootEntry`` objects matching
        the given criteria.

        :param boot_id: ``boot_id`` to match.
        :param title: the title of the new entry.
        :param version: the version string for the new entry.
        :param root_device: the root device path for the new entry.
        :param lvm_root_lv: an optional LVM2 root logical volume.
        :param btrfs_subvol_path: an optional BTRFS subvolume path.
        :param btrfs_subvol_id: an optional BTRFS subvolume id.
        :param osprofile: The ``OsProfile`` for this entry.
        :returns: the ``boot_id`` of the new entry.
        :returntype: list
    """
    bes = find_entries(boot_id=boot_id, title=title, version=version,
                       machine_id=machine_id, root_device=root_device,
                       lvm_root_lv=lvm_root_lv,
                       btrfs_subvol_path=btrfs_subvol_path,
                       btrfs_subvol_id=btrfs_subvol_id)

    return bes


def print_entries(boot_id=None, title=None, version=None,
                  machine_id=None, root_device=None, lvm_root_lv=None,
                  btrfs_subvol_path=None, btrfs_subvol_id=None,
                  output_fields=None, opts=None):
    """print_entries(boot_id, title, version,
                    machine_id, root_device, lvm_root_lv,
                    btrfs_subvol_path, btrfs_subvol_id) -> list

        Format a set of ``boom.bootloader.BootEntry`` objects matching
        the given criteria, and output them as a report to the file
        given in ``out_file``, or ``sys.stdout`` if ``out_file`` is
        unset.

        :param boot_id: ``boot_id`` to match.
        :param title: the title of the new entry.
        :param version: the version string for the new entry.
        :param root_device: the root device path for the new entry.
        :param lvm_root_lv: an optional LVM2 root logical volume.
        :param btrfs_subvol_path: an optional BTRFS subvolume path.
        :param btrfs_subvol_id: an optional BTRFS subvolume id.
        :param opts: output formatting and control options.
        :param fields: a table of ``BoomFieldType`` field descriptors.
        :returns: the ``boot_id`` of the new entry.
        :returntype: str
    """
    opts = opts if opts else BoomReportOpts()

    if not output_fields:
        output_fields = _default_entry_fields

    bes = find_entries(boot_id=boot_id, title=title, version=version,
                       machine_id=machine_id, root_device=root_device,
                       lvm_root_lv=lvm_root_lv,
                       btrfs_subvol_path=btrfs_subvol_path,
                       btrfs_subvol_id=btrfs_subvol_id)

    br = BoomReport(_report_obj_types, _entry_fields + _profile_fields,
                    output_fields, opts, None, None)
    for be in bes:
        br.report_object(BoomReportObj(be, be._osp))

    return br.report_output()

#
# OsProfile manipulation
#

def list_profiles(os_id=None, name=None, short_name=None,
                  version=None, version_id=None, uname_pattern=None,
                  kernel_pattern=None, initramfs_pattern=None,
                  root_opts_lvm2=None, root_opts_btrfs=None, options=None):
    """list_profiles(os_id, name, short_name,
                     version, version_id, uname_pattern,
                     kernel_pattern, initramfs_pattern,
                     root_opts_lvm2, root_opts_btrfs, options) -> list

        Return a list of ``boom.osprofile.OsProfile`` objects matching
        the given criteria.

        :param os_id: The boot identifier to match.
        :param name: The profile name to match.
        :param short_name: The profile short name to match.
        :param version: The version string to match.
        :param version_id: The version ID string to match.
        :param uname_pattern: The ``uname_pattern`` value to match.
        :param kernel_pattern: The kernel pattern to match.
        :param initramfs_pattern: The initial ramfs pattern to match.
        :param options: The options template to match.
        :returns: a list of ``OsProfile`` objects.
        :returntype: list
    """
    osps = find_profiles(os_id=os_id, name=name, short_name=short_name,
                         version=version, version_id=version_id,
                         uname_pattern=uname_pattern,
                         kernel_pattern=kernel_pattern,
                         initramfs_pattern=initramfs_pattern,
                         options=options)

    return osps


def print_profiles(os_id=None, name=None, short_name=None,
                   version=None, version_id=None, uname_pattern=None,
                   kernel_pattern=None, initramfs_pattern=None,
                   root_opts_lvm2=None, root_opts_btrfs=None, options=None,
                   opts=None, output_fields=None):
    """print_profiles(os_id, name, short_name,
                      version, version_id, uname_pattern,
                      kernel_pattern, initramfs_pattern,
                      root_opts_lvm2, root_opts_btrfs, options) -> list

        :param os_id: The boot identifier to match.
        :param name: The profile name to match.
        :param short_name: The profile short name to match.
        :param version: The version string to match.
        :param version_id: The version ID string to match.
        :param uname_pattern: The ``uname_pattern`` value to match.
        :param kernel_pattern: The kernel pattern to match.
        :param initramfs_pattern: The initial ramfs pattern to match.
        :param root_opts_lvm2: The LVM2 root options template to match.
        :param root_opts_btrfs: The BTRFS root options template to match.
        :param options: The options template to match.
        :returns: the number of matching profiles output.
        :returntype: int
    """
    opts = opts if opts else BoomReportOpts()

    if not output_fields:
        output_fields = _default_profile_fields

    osps = find_profiles(os_id=os_id, name=name, short_name=short_name,
                         version=version, version_id=version_id,
                         uname_pattern=uname_pattern,
                         kernel_pattern=kernel_pattern,
                         initramfs_pattern=initramfs_pattern,
                         root_opts_lvm2=root_opts_lvm2,
                         root_opts_btrfs=root_opts_btrfs,
                         options=options)

    br = BoomReport(_report_obj_types, _profile_fields, output_fields, opts,
                    None, None)

    for osp in osps:
        br.report_object(BoomReportObj(None, osp))

    return br.report_output()

#
# boom command line tool
#

def _create_cmd(cmd_args):
    pass


def _delete_cmd(cmd_args):
    pass


def _list_cmd(cmd_args):
    if cmd_args.fields:
        fields = cmd_args.fields
    elif cmd_args.verbose:
        fields = _verbose_entry_fields
    else:
        fields = None
    try:
        print_entries(output_fields=fields)
    except ValueError:
        return 1


def _edit_cmd(cmd_args):
    pass


def _create_profile_cmd(cmd_args):
    pass


def _delete_profile_cmd(cmd_args):
    pass


def _list_profile_cmd(cmd_args):
    if cmd_args.fields:
        fields = cmd_args.fields
    elif cmd_args.verbose:
        fields = _verbose_profile_fields
    else:
        fields = None
    try:
        print_profiles(output_fields=fields)
    except ValueError:
        return 1


def _edit_profile_cmd(cmd_args):
    pass


boom_usage = """%(prog}s [type] <command> [options]\n\n"
                [entry] create <title> <version> [--osprofile=os_id] [...]
                [entry] delete [title|version|boot_id|os_id]
                [entry] list [title|version|boot_id|os_id|root_device|machine_id]\n\n
                [entry] edit [...]
                profile create <name> <shortname> <version> <versionid> [...]
                profile delete [...]
                profile list [...]
                profile edit [...]
             """

_boom_entry_commands = [
    ("create", _create_cmd),
    ("delete", _delete_cmd),
    ("list", _list_cmd),
    ("edit", _edit_cmd)
]

_boom_profile_commands = [
    ("create", _create_profile_cmd),
    ("delete", _delete_profile_cmd),
    ("list", _list_profile_cmd),
    ("edit", _edit_profile_cmd)
]

_boom_command_types = [
    ("entry", _boom_entry_commands),
    ("profile", _boom_profile_commands)
]


def _match_cmd_type(cmdtype):
    for t in _boom_command_types:
        if cmdtype == t[0]:
            return t
    return None


def _match_command(cmd, cmds):
    for c in cmds:
        if cmd == c[0]:
            return c
    return None


def main(args):
    global _boom_entry_commands, _boom_profile_commands, _boom_command_types
    parser = ArgumentParser(prog=basename(args[0]),
                            description="Boom Boot Manager")

    # Default type is boot entry.
    if _match_command(args[1], _boom_entry_commands):
        args.insert(1, "entry")

    parser.add_argument("type", metavar="[TYPE]", type=str,
                        help="The command type to run", action="store")
    parser.add_argument("command", metavar="COMMAND", type=str,
                        help="The command to run", action="store")
    parser.add_argument("-t", "--title", metavar="TITLE", type=str, nargs=1,
                        help="The title of a boom boot entry")
    parser.add_argument("-V", "--version", metavar="VERSION", type=str,
                        nargs=1, help="The kernel version of a boom "
                        "boot entry")
    parser.add_argument("-b", "--boot-id", metavar="BOOT_ID", type=str,
                        nargs=1, help="The BOOT_ID of a boom boot entry")
    parser.add_argument("-o", "--os-profile", metavar="OS_ID", type=str,
                        nargs=1, help="A boom operating system profile "
                        "identifier")
    parser.add_argument("-r", "--root-device", metavar="ROOT", type=str,
                        nargs=1, help="The root device for a boot entry")
    parser.add_argument("-m", "--machine-id", metavar="MACHINE_ID", type=str,
                        nargs=1, help="The machine_id value to use")
    parser.add_argument("-f", "--fields", metavar="FIELDS", type=str,
                        help="Specify which fields to display")
    parser.add_argument("-v", "--verbose", help="Enable verbose ouput",
                        action="store_true")
    cmd_args = parser.parse_args()

    cmd_type = _match_cmd_type(cmd_args.type)
    if not cmd_type:
        print("Unknown command type: %s" % cmd_args.type)
        return 1

    type_cmds = cmd_type[1]
    command = _match_command(cmd_args.command, type_cmds)
    if not command:
        print("Unknown command: %s %s" % (cmd_type[0], cmd_args.command))
        return 1

    return command[1](cmd_args)

# vim: set et ts=4 sw=4 :
